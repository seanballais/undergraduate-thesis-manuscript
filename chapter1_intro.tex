\chapter{Introduction} \label{sec:intro}

A common activity in universities and all academic institutions is course timetabling. This activity is a necessity in academic institutions as this is where classes are scheduled for the incoming semester. In some instances, even entire courses are scheduled for at least four years \cite{alves-novel-recursive}. Performing timetabling manually is tedious and schedules conflicts may not immediately be determined \cite{nlgdrl-obit}. As such, automating this procedure will be beneficial to academic institutions. This problem of automating course scheduling is actually formally known as the University Course Timetabling Problem (UTP) \cite{yousef-gpu-ga}\cite{socha-maxmin-ant-system}. Many works have already proposed different approaches to automate the timetabling process. Some of the algorithms that were utilized by proposed appraoches include great deluge \cite{gd-burked}\cite{nlgd-landa-silva}, machine learning \cite{nlgdrl-obit}, and genetic algorithms \cite{bedoya-non-standard-ga}\cite{raghavjee-ga-south-africa}\cite{yik-ga-timetabling}. Their results produce optimal timetables, or near to the optimal, at least for the case they were originally intended for. Applying their approaches to other institutions \textit{may} require some tweaking to fit in with the new environment they are going to be used in. There is no one approach that works for all cases as is. Due to this, there is a considerable amount of research that is done and is being done in further refining and discovering methods for automatic timetabling.

\section{The University Course Timetabling Problem}
The University Course Timetabling (UCT) Problem is a problem where $l$ lectures are being placed into a $t$ timeslots and $r$ rooms in such a way that it will result in a feasible timetable \cite{nlgd-landa-silva}. It was proven by Cooper, T. and Kingston, J. that this problem is an NP-complete problem which means it is difficult to produce feasible timetables \cite{cooper-timetable-problem-complexity}. Identifying whether a timetable is feasible or not is determined by two types of constraints: (a) hard constraints, and (b) soft constraints

Hard constraints are constraints that are not supposed to be violated. Violation of these constraints immediately leads infeasibility of a potential. Some proposed approaches immediately discard timetables that are infeasible \cite{nlgd-landa-silva}\cite{nlgdrl-obit}, while others would give high penalty costs for each hard constraint violated \cite{supachate-noval-approach-ga-thai}. The set hard constraints may differ from one approach to another. However, a common hard constraint that can be observed across approaches is that a student, and, naturally, a teacher as well, cannot attend two or more classes in the same timeslot \cite{nlgd-landa-silva}\cite{bedoya-non-standard-ga}. This is obvious as a person cannot be in two or more places at the same time. These hard constraints are what all constructed timetables must satisfy to be considered as a potential solution.

The counterpart to hard constraints are soft constraints. Unlike, hard constraints, soft constraints are \textit{technically} optional for timetables to satisfy. However, finding the best timetables for a given problem require minimization of the number of soft constraints being violated \cite{nlgd-landa-silva}. The set soft constraints differ from one case to another. Another case might require soft constraints that are not present in another case. For example, one approach \cite{nlgdrl-obit} has a soft constraint where students should not have only one class in a single day, while another \cite{supachate-noval-approach-ga-thai} does not and instead does not allow having more than three lectures of the same class schedule adjacently on the same day.	Many approaches do not consider hard constraints in computing the fitness value of a timetable. Instead, many only use the soft constraints as part of their fitness function \cite{sanjay-an-application-of-ga}\cite{nlgdrl-obit}\cite{bedoya-non-standard-ga}.

\section{Algorithms Used In Approaches For Solving the University Course Timetabling Problem}
\subsection{Great Deluge}
Many previous works dealing with course timetabling utilize an optimizing heuristic (or derivatives of it) called \textbf{Great Deluge}. Great Deluge was introduced by Gunter Dueck, and is a heuristic that is similar to Hill Climbing and Simulated Annealing. To understand how it works, imagine that you are in a point in some area with mountainous terrain. This area constitutes your solution space, with higher points in the area having higher values and, thus, having a better solution. The initial point you are located in in the area represents the initial solution that is generated. Imagine as well that it is raining endlessly and the water level $W$ is continuously rising at a constant rate $R_{w}$, where $R_{w}$. $W$ can start at any value that is greater than $0$. Assuming that we are attempting to maximize some function $Q$, which evaluates a solution based on some criteria, your goal is to locate the relatively highest point in the location. This point can be thought of as the local optimum. Locating the highest point involves walking around the area that is not below the current water level. This will force you to walk to a higher and higher point since $W$ is constantly rising. Once you are no longer able to proceed to a higher level, it means that you are now in a local optimum. Going outside the analogy and back to a technical perspective, this local optimum would now be the \textit{relatively} best solution for your problem. Every "walk" or move to a higher point is nuanced relative to the analogy. A single walk means construction of a new solution $S_{new}$ with basis on the current solution $S_{current}$. If $Q(S_{new}) \geq W$ \cite{gd-burke}, then we accept $S_{new}$ as the new current solution and "walk" towards it, and we increase $W$ by $R_{w}$. Otherwise, we simply generate a new $S_{new}$. These walks are performed until $Q(S_{new})$ is not greater than $Q(S_{curr})$ for a long time or we have reached the maximum number of moves/iterations \cite{intro-gd-dueck}. Great Deluge can also be adapted to minimize $Q$. Instead of $W$ increasing, it will be decreasing by the same rate. A solution $S$ will now be accepted if $Q(S) \leq W$. Conversely, the algorithm will stop when $Q(S_{new})$ is not lesser than $Q(S_{curr})$. The second stopping condition for the algorithm still applies in this case \cite{gd-burke}\cite{nlgd-landa-silva}\cite{nlgdrl-obit}. This minimization case is the one adapted by Great Deluge-based works that focus on course timetabling.

\subsection{Genetic Algorithms}
Great Deluge is a metaheuristic \cite{intro-gd-dueck} that has been used for solving course timetabling problems \cite{gd-burke}\cite{nlgd-landa-silva}\cite{nlgdrl-obit}. Aside from Great Deluge, another metaheuristic that has seen use in the course timetabling problem and its variations is the Genetic Algorithm. The genetic algorithm is an optimization algorithm whose behaviour is based on how nature works, particularly on how reproduction works at a genetic level. Many implementations of the genetic algorithm for course timetabling represents the problem by having each gene in the genetic representation of the timetabling be a two-element tuple which consists of the class and the agents that will partake in that said class \cite{alves-novel-recursive}\cite{raghavjee-ga-south-africa}\cite{supachate-noval-approach-ga-thai}. Some use another representation. In the algorithm, an initial population is first generated. This population does not necessarily contain the locally optimal solution but it is where the relatively best solution will be obtained from. This initial population is referred to as the first generation. From this population, a certain number of individuals will be randomly selected to be bred with one another and be the parents of the next generation. Selection of individuals is dependent on an individual's fitness, with the most fit individuals usually being selected. Calculating this fitness is dependent on the problem. In the context of course timetabling, fitness is based on the constraints that have been violated by the current solution/timetable generated \cite{alves-novel-recursive}\cite{raghavjee-ga-south-africa}\cite{johan-ga-sa-comparison}\cite{yik-ga-timetabling}\cite{supachate-noval-approach-ga-thai}\cite{wutthipong-performance-study-genetic-operators}\cite{sanjay-an-application-of-ga}. The breeding process involves selection of parents and having genes from the parents crossover and/or mutate to produce new offspring. Crossover is when genes from both parents are combined to produce an offspring. On the other hand, mutation is done by changing a random gene from either parent to create an offspring. Determining which genes from either parent to apply onto the offspring and which to mutate is dependent on implementation. Once a population of new generations is established, the cycle repeats. This continuous reproduction of generations eventually produces solutions "moves" towards the optimal solution \cite{what-is-ga}. Despite being able to produce feasible solutions for university timetabling, it should be noted that using a genetic algorithm approach may require more time executing compared to other approaches due to its population-based property. When compared to simulated annealing, another approach for university timetabling, the genetic algorithm takes more time executing \cite{johan-ga-sa-comparison}. However, approaches utilizing the genetic algorithm can see an improvement in execution time when they utilize graphics processing units (GPUs). The work of Yousef, A., Salama, C., Jad, M., El-Gafy, T., Matar, M., and Habashi, S. showed that it is possible to speed up genetic algorithms using GPUs. In their work, they accelerated the computation of the fitness function. Their experiments show that execution speed can be improved by up to 59 times in very large problem instances and by 280\% overall when utilizing the GPU \cite{yousef-gpu-ga}.

% Discuss about Tabu Search.

%
%
%
%
%