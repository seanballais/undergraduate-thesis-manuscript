\chapter{Introduction} \label{sec:intro}

A common activity in universities and all academic institutions is course timetabling. This activity is a necessity in academic institutions as this is where classes are scheduled for the incoming semester. In some instances, even entire courses are scheduled for at least four years \cite{alves-novel-recursive}. Performing timetabling manually is tedious and schedules conflicts may not immediately be determined \cite{nlgdrl-obit}. As such, automating this procedure will be beneficial to academic institutions. This problem of automating course scheduling is actually formally known as the University Course Timetabling Problem (UTP) \cite{yousef-gpu-ga}\cite{socha-maxmin-ant-system}. Many works have already proposed different approaches to automate the timetabling process. Some of the algorithms that were utilized by proposed appraoches include great deluge \cite{gd-burked}\cite{nlgd-landa-silva}, machine learning \cite{nlgdrl-obit}, and genetic algorithms \cite{bedoya-non-standard-ga}\cite{raghavjee-ga-south-africa}\cite{yik-ga-timetabling}. Their results produce optimal timetables, or near to the optimal, at least for the case they were originally intended for. Applying their approaches to other institutions \textit{may} require some tweaking to fit in with the new environment they are going to be used in. There is no one approach that works for all cases as is. Due to this, there is a considerable amount of research that is done and is being done in further refining and discovering methods for automatic timetabling.

\section{The University Course Timetabling Problem}
The University Course Timetabling (UCT) Problem is a problem where $l$ lectures are being placed into a $t$ timeslots and $r$ rooms in such a way that it will result in a feasible timetable \cite{nlgd-landa-silva}. It was proven by Cooper, T. and Kingston, J. that this problem is an NP-complete problem which means it is difficult to produce feasible timetables \cite{cooper-timetable-problem-complexity}. Identifying whether a timetable is feasible or not is determined by two types of constraints: (a) hard constraints, and (b) soft constraints

Hard constraints are constraints that are not supposed to be violated. Violation of these constraints immediately leads infeasibility of a potential. Some proposed approaches immediately discard timetables that are infeasible \cite{nlgd-landa-silva}\cite{nlgdrl-obit}, while others would give high penalty costs for each hard constraint violated \cite{supachate-noval-approach-ga-thai}. The set hard constraints may differ from one approach to another. However, a common hard constraint that can be observed across approaches is that a student, and, naturally, a teacher as well, cannot attend two or more classes in the same timeslot \cite{nlgd-landa-silva}\cite{bedoya-non-standard-ga}. This is obvious as a person cannot be in two or more places at the same time. These hard constraints are what all constructed timetables must satisfy to be considered as a potential solution.

The counterpart to hard constraints are soft constraints. Unlike, hard constraints, soft constraints are \textit{technically} optional for timetables to satisfy. However, finding the best timetables for a given problem require minimization of the number of soft constraints being violated \cite{nlgd-landa-silva}. The set soft constraints differ from one case to another. Another case might require soft constraints that are not present in another case. For example, one approach \cite{nlgdrl-obit} has a soft constraint where students should not have only one class in a single day, while another \cite{supachate-noval-approach-ga-thai} does not and instead does not allow having more than three lectures of the same class schedule adjacently on the same day.	Many approaches do not consider hard constraints in computing the fitness value of a timetable. Instead, many only use the soft constraints as part of their fitness function \cite{sanjay-an-application-of-ga}\cite{nlgdrl-obit}\cite{bedoya-non-standard-ga}.

\section{Timetabling in The University of the Philippines Visayas Tacloban College}
The University of the Philippines Visayas Tacloban College is, at the time of writing, a college under the administration of the University of the Philippines Visayas, a constituent of the University of the Philippines System. The college consists of four divisions: Division of Natural Sciences and Mathematics, Division of Humanities, Division of Social Sciences, and Division of Management. Through these divisions, the college offers eight undegraduates degrees: BS Computer Science, BS Biology, BA Social Sciences in Political Science, BA Social Sciences in Economics, BA Psychology, BA Communication Arts, BS Accountancy, and BS Management. Each of these degrees offer classes that are required to be attended and completed by the students undertaking the degree. These classes last from one hour to one and a half hours per session. A session of a lecture-only classes is allocated $1$ hour and $30$ minutes, while sessions for PE classes and lecture classes with laboratory sessions are given just $1$ hour. A class can only have one session per half-week or week if scheduled on a Wednesday. A half-week consists of the first or last two days of a weekday. Classes retain their usual scheduling if scheduled on a half-week but are given twice their usual timeslots when scheduled on a Wednesday. When a class is scheduled in the first half-week, then its schedule is mirrored in the next half-week on its counterpart day. For example, if a class session is scheduled on a Monday at 1PM, then another session of the class is scheduled on Thursday at 1PM. A class is usually assigned a room that is reserved to the division the class is offered by. As such, the chances that two classes from different divisions will share the same room is unlikely. Two or more instances (sections in the terms of the college) of the same class may be offered by the division depending on the necessity but may be taught by different teachers and in different rooms and, obviously, time slots. Scheduling these classes are typically done manually. The classes of each division are scheduled by a the division chair. Teachers may specify their preferred teaching times and the division chair tries his/her best to accomodate their preferences as much as possible.
% Talk about how a division chair schedules.
For our timetabling model, we can determine the following hard constraints basing from the aforementioned setup:

\begin{itemize}
	\item No two classes scheduled in the same timeslot can have the same students and teachers.
	\item Each room can only accomodate one class per timeslot.
\end{itemize}

We can also formulate the following soft constraints:

\begin{itemize}
	\item A class must be scheduled in rooms that are reserved for the division the class is offered by.
	\item As much as possible, no classes should be scheduled on the timeslots, 7AM to 8:30AM, and 5:30PM to 7PM.
	\item No class must be scheduled in the timeslot unpreferable to the teacher assigned to the class.
\end{itemize}

Computing the objective function will be based on these soft constraints. Each soft constraint will be given a weight which will represent the constraint priority in terms of being satisfied and to help steer the timetable towards a schedule that is more satisfactory to students and teachers. It should be noted that the third soft constraint will cause the timetabling model to not guarantee complete optimality of timetables, with complete optimality being the state in which no soft constraints are ever violated.

\section{Algorithms Used In Approaches For Solving the University Course Timetabling Problem}
\subsection{Great Deluge}
Many previous works dealing with course timetabling utilize an optimizing heuristic (or derivatives of it) called \textbf{Great Deluge}. Great Deluge was introduced by Gunter Dueck, and is a heuristic that is similar to Hill Climbing and Simulated Annealing. To understand how it works, imagine that you are in a point in some area with mountainous terrain. This area constitutes your solution space, with higher points in the area having higher values and, thus, having a better solution. The initial point you are located in in the area represents the initial solution that is generated. Imagine as well that it is raining endlessly and the water level $W$ is continuously rising at a constant rate $R_{w}$, where $R_{w}$. $W$ can start at any value that is greater than $0$. Assuming that we are attempting to maximize some function $Q$, which evaluates a solution based on some criteria, your goal is to locate the relatively highest point in the location. This point can be thought of as the local optimum. Locating the highest point involves walking around the area that is not below the current water level. This will force you to walk to a higher and higher point since $W$ is constantly rising. Once you are no longer able to proceed to a higher level, it means that you are now in a local optimum. Going outside the analogy and back to a technical perspective, this local optimum would now be the \textit{relatively} best solution for your problem. Every "walk" or move to a higher point is nuanced relative to the analogy. A single walk means construction of a new solution $S_{new}$ with basis on the current solution $S_{current}$. If $Q(S_{new}) \geq W$ \cite{gd-burke}, then we accept $S_{new}$ as the new current solution and "walk" towards it, and we increase $W$ by $R_{w}$. Otherwise, we simply generate a new $S_{new}$. These walks are performed until $Q(S_{new})$ is not greater than $Q(S_{curr})$ for a long time or we have reached the maximum number of moves/iterations \cite{intro-gd-dueck}. Great Deluge can also be adapted to minimize $Q$. Instead of $W$ increasing, it will be decreasing by the same rate. A solution $S$ will now be accepted if $Q(S) \leq W$. Conversely, the algorithm will stop when $Q(S_{new})$ is not lesser than $Q(S_{curr})$. The second stopping condition for the algorithm still applies in this case \cite{gd-burke}\cite{nlgd-landa-silva}\cite{nlgdrl-obit}. This minimization case is the one adapted by Great Deluge-based works that focus on course timetabling.

%\subsection{Linear Programming}
%\subsubsection{Integer Programming}

\subsection{Genetic Algorithms}
Great Deluge is a metaheuristic \cite{intro-gd-dueck} that has been used for solving course timetabling problems \cite{gd-burke}\cite{nlgd-landa-silva}\cite{nlgdrl-obit}. Aside from Great Deluge, another metaheuristic that has seen use in the course timetabling problem and its variations is the Genetic Algorithm. The genetic algorithm is an optimization algorithm whose behaviour is based on how nature works, particularly on how reproduction works at a genetic level. Many implementations of the genetic algorithm for course timetabling represents the problem by having each gene in the genetic representation of the timetabling be a two-element tuple which consists of the class and the agents that will partake in that said class \cite{alves-novel-recursive}\cite{raghavjee-ga-south-africa}\cite{supachate-noval-approach-ga-thai}. Some use another representation. In the algorithm, an initial population is first generated. This population does not necessarily contain the locally optimal solution but it is where the relatively best solution will be obtained from. This initial population is referred to as the first generation. From this population, a certain number of individuals will be randomly selected to be bred with one another and be the parents of the next generation. Selection of individuals is dependent on an individual's fitness, with the most fit individuals usually being selected. Calculating this fitness is dependent on the problem. In the context of course timetabling, fitness is based on the constraints that have been violated by the current solution/timetable generated \cite{alves-novel-recursive}\cite{raghavjee-ga-south-africa}\cite{johan-ga-sa-comparison}\cite{yik-ga-timetabling}\cite{supachate-noval-approach-ga-thai}\cite{wutthipong-performance-study-genetic-operators}\cite{sanjay-an-application-of-ga}. The breeding process involves selection of parents and having genes from the parents crossover and/or mutate to produce new offspring. Crossover is when genes from both parents are combined to produce an offspring. On the other hand, mutation is done by changing a random gene from either parent to create an offspring. Determining which genes from either parent to apply onto the offspring and which to mutate is dependent on implementation. Once a population of new generations is established, the cycle repeats. This continuous reproduction of generations eventually produces solutions "moves" towards the optimal solution \cite{what-is-ga}. Despite being able to produce feasible solutions for university timetabling, it should be noted that using a genetic algorithm approach may require more time executing compared to other approaches due to its population-based property. When compared to simulated annealing, another approach for university timetabling, the genetic algorithm takes more time executing \cite{johan-ga-sa-comparison}. However, approaches utilizing the genetic algorithm can see an improvement in execution time when they utilize graphics processing units (GPUs). The work of Yousef, A., Salama, C., Jad, M., El-Gafy, T., Matar, M., and Habashi, S. showed that it is possible to speed up genetic algorithms using GPUs. In their work, they accelerated the computation of the fitness function. Their experiments show that execution speed can be improved by up to 59 times in very large problem instances and by 280\% overall when utilizing the GPU \cite{yousef-gpu-ga}.

% Discuss about Tabu Search.

%
%
%
%
%