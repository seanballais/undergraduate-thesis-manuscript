\chapter{Methodology}
The methodology used in this research uses a modification of the classical Grey Wolf Optimization algorithm first introduced by Mirjalili, S., Mirjalili, S., and Lewis, A. in 2014 \cite{Mirjalili2014}. As we will be discussing in this chapter, we have determined that using classical GWO as is does not result in usable solutions for the instance of facility layout problem we are solving. Hence, the necessity for the modification.

In this chapter, we will first discuss about the mathematical model of the problem being solved. Later, we will be delving into the inner workings of the solution representation, the algorithm (including the justification for the modification), and then the technologies that were used in implementing the approach.

\section{Mathematical Model}
The goal of any metaheuristic, like what is being proposed in this paper, is to optimize a certain objective function. As mentioned in the first chapter, in facility layout problems, we minimize the following function:

$$
\text{min} F = \sum_{i=1}^{n}\sum_{j=1}^{n}c_{ij}f_{ij}d_{ij}
$$

For the problem we are solving in this paper, we are optimizing the following equation that is not only a slight modification of the basic mathematical model for FLPs, but also adds penalties to solutions that are infeasible, no matter the degree of infeasiblity.

\begin{align*}
	\text{min }F &= \sum_{i=1}^{\left | B \right |}\sum_{j=i + 1}^{\left | B \right |}c_{ij}d_{ij} \\
	& + \sum_{i=1}^{\left | B \right |}\sum_{j=i + 1}^{\left | B \right |} \left ( P_{B}\frac{A_{0}(i, j)}{\text{min}(w_{i}h_{i}, w_{j}h_{j})} + P_{B} \right ) \cdot \alpha_{0}(i, j) \\
	& + \sum_{i=1}^{\left | B \right |}\left( P_{R}\frac{w_{i}h_{i} - A_{1}(i)}{w_{i}h_{i}} + P_{R} \right) \cdot \alpha_{1}(i)
\end{align*}

where:

\begin{table}[h!]
	\centering
	\begin{tabular}{| l | p{10cm} |}
	\hline
	$x_{i}$  & top-left $x$ coordinate of building $i$ \\
	\hline
	$y_{i}$  & top-left $y$ coordinate of building $i$ \\
	\hline
	$w_{i}$  & width of building $i$ \\
	\hline
	$h_{i}$  & height of building $i$ \\
	\hline
	$R_{x}$  & top-left $x$ coordinate of the bounding region \\
	\hline
	$R_{y}$  & top-left $y$ coordinate of the bounding region \\
	\hline
	$R_{w}$  & width of the bounding region \\
	\hline
	$R_{h}$  & height of the bounding region \\
	\hline
	$c_{ij}$ & flow rate from building $i$ to building $j$ \\
	\hline
	$d_{ij}$ & distance from the center of building $i$ to the
	           center of building $j$ \\
	\hline
	$P_{B}$  & penalty value for building intersection \\
	\hline
	$P_{T}$  & penalty value for any building going out of
	           bounds, even with a portion of a building \\
	\hline
	\end{tabular}
\end{table}

We elected to remove the flow rate from the basic formulation of the model that was discussed earlier in Equation \ref{mm-equation-mhc}. 

\begin{equation}\label{mm-equation-mhc}
	\sum_{i=1}^{\left | B \right |}\sum_{j=i + 1}^{\left | B \right |}c_{ij}d_{ij}
\end{equation}

This is because we can consider flow rate as simply part of the cost. In the original formulation, we were considering it from a material handling cost perspective, which requires having both a cost and flow rate variable. However, in a general problem, we can consider cost to also include the frequency of movement from one facility to another, which is essentially the flow rate. As such, we can merge cost and flow rate into one variable.

The mathematical model allows for infeasible solutions to allow for better solutions in the long run. To follow this specification, the model includes expressions that penalizes solutions that meet any of the following conditions: (1) at least one building is intersecting with another building, and (2) a building, either in whole or in part, is outside the bounding area.

\begin{equation}\label{mm-equation-intersection}
	\sum_{i=1}^{\left | B \right |}\sum_{j=i + 1}^{\left | B \right |} \left ( P_{B}\frac{A_{0}(i, j)}{\text{min}(w_{i}h_{i}, w_{j}h_{j})} + P_{B} \right ) \cdot \alpha_{0}(i, j)
\end{equation}

Equation \ref{mm-equation-intersection} is the expression that applies a penalty to solutions that meet the first condition. Notice that it has the functions $A_{0}(i, j)$ and $\alpha_{0}(i, j)$. They are defined by the following:

\begin{align}
	A_{0}(i, j) &= I_{L}(x_{i}, x_{j}, w_{i}, w_{j})
	               \cdot I_{L}(y_{i}, y_{j}, h_{i}, h_{j}) \\
	I_{L}(x_{1}, x_{2}, l_{1}, l_{2}) &= \text{max}(0, \text{min}(x_{1} + l_{1}, x_{2} + l_{2}) - \text{max}(x_{1}, x_{2})) \\
    \alpha_{0}(i, j) &=
    \left\{\begin{matrix}
    	1 & \text{if } A_{0}(i, j) > 0 \\ 
    	0 & \text{otherwise}
    \end{matrix}\right.
\end{align}

$A_{0}(i, j)$ simply gets the area of intersection of buildings $i$ and $j$. This is achieved by the use of $I_{L}(x_{1}, x_{2}, l_{1}, l_{2})$, which computes the length or width of an intersection of buildings.

In the equation, for every pair of buildings that intersect, we apply a penalty that is the percentage of the area of the smallest building by area that is intersecting with the other building multiplied by the penalty value for building intersection. This will allow for rewarding the algorithm for moving the buildings towards non-intersection. The same penalty value is also added to ensure that the algorithm prioritizes removing intersections over reducing the distance between the centers of the buildings. $\alpha_{0}(i, j)$ ensures that the penalty is only applied to pairs of buildings that intersect with one another.

\begin{equation}\label{mm-equation-oob}
	\sum_{i=1}^{\left | B \right |}\left( P_{R}\frac{w_{i}h_{i} - A_{1}(i)}{w_{i}h_{i}} + P_{R} \right) \cdot \alpha_{1}(i)
\end{equation}

The other part of the mathematical model, Equation \ref{mm-equation-oob}, works in a similar principle as Equation \ref{mm-equation-intersection}. This equation applies a penalty value when the second condition of infeasibility is met. Like in \ref{mm-equation-intersection}, it has specific functions to help compute the penalty. They are defined as:

\begin{align}
	A_{1}(i) &= I_{L}(x_{i}, R_{x}, w_{i}, R_{w})
	\cdot I_{L}(y_{i}, R_{y}, h_{i}, R_{h}) \\
	\alpha_{1}(i) &=
	\left\{
	\begin{matrix}
		0 & \text{if} &
		\begin{aligned}
			R_{x} &\leq x_{i} &\leq R_{x} + R_{w} \\
			R_{x} &\leq x_{i} + w_{i} &\leq R_{x} + R_{w} \\
			R_{y} &\leq y_{i} &\leq R_{y} + R_{h} \\
			R_{y} &\leq y_{i} + h_{i} &\leq R_{y} + R_{h} \\
		\end{aligned} \\		
		1 & \text{otherwise}
	\end{matrix}\right.
\end{align}

$A_{1}(i)$ simply computes the area of intersection of the building and the bounding area. Now, since this only computes the intersection, we must subtract the intersection with the area of the building to get the area of the building that is outside of the bounding area. This is expressed by the numerator of the fractional expression in Equation \ref{mm-equation-oob}. Similar to Equation \ref{mm-equation-intersection}, the equation applies a penalty value that is the percentage of the area of the total building area that is outside the bounding region multiplied and then added by the penalty value. The addition is also to ensure that the algorithm gives more priority to removing out-of-bounds buildings. $\alpha_{1}(i)$ ensures that the penalty is only applied to buildings that are, in part or in whole, out of bounds.

\section{Solution Representation}
The solution is represented using a one-dimensional array of floating numbers. In the array, every group of three consecutive elements are considered to be the x and y positions, and angle, respectively, of one building. While the x and y positions are allowed to be of any value, the angle value is restricted to only $0^{\circ}$ and $90^{\circ}$. A visualization of the solution representation is shown by Figure \ref{solution-repr-viz}.

\begin{figure}
	\begin{center}
		\begin{tabular}{| c | c | c | c | c | c | c |}
			\hline
			$x_{0}$ & $y_{0}$ & $\angle_{0}$ & $\ddots$ & $x_{n - 1}$ & $y_{n - 1}$ & $\angle_{n - 1}$ \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Visualization of the solution representation.}
	\label{solution-repr-viz}
\end{figure}

\section{The Algorithm}
In this paper, we are adapting the Grey Wolf Optimization algorithm into solving our instance of the facility layout problem. There have been no publicly available research that have previously used the metaheuristic in solving FLP, basing from our survey. This increases the significance of this paper. As mentioned earlier, the proposed algorithm requires modifications in order to produce feasible solutions. We will first be discussing the reasons why we require them, before proceeding to detailing the algorithm we are using for this research.

\subsection{The Problem with Classical GWO}
In classical GWO, the following equations are used:

\begin{align}
	\vec{X_{1}^{'}} &= \vec{X_{\alpha}}(t) - \vec{A_{\alpha}} \cdot \vec{D_{\alpha}} \label{gwo-x1-eqn} \\
	\vec{X_{2}^{'}} &= \vec{X_{\beta}}(t) - \vec{A_{\beta}} \cdot \vec{D_{\beta}} \\
	\vec{X_{3}^{'}} &= \vec{X_{\delta}}(t) - \vec{A_{\delta}} \cdot \vec{D_{\delta}} \\
	\vec{X}(t + 1)  &= \frac{\vec{X_{1}^{'}} + \vec{X_{2}^{'}} + \vec{X_{3}^{'}}}{3} \label{gwo-xt1-eqn}
\end{align}

where $\vec{X_{\alpha}}$, $\vec{X_{\beta}}$, and $\vec{X_{\delta}}$ represent the $\alpha$, $\beta$, and $\delta$ solutions \cite{Gupta2018}. $\vec{D}$ and $\vec{A}$ are defined as:

\begin{align*}
	\vec{D}        &= \left | \vec{C} \cdot \vec{X_{l}}(t)
	- \vec{X}(t) \right | \\
	\vec{C}        &= 2 \cdot \vec{r_{2}} \\
	\vec{A}        &= 2 \cdot \vec{a} \cdot \vec{r_{1}}
					  - \vec{a}                \\
\end{align*}

The aforementioned equations may be usable as is for other problems. However, as we have discovered through our experiments, using these equations results in solutions that are infeasible and where the buildings tend to move to the axes of an origin and the origin itself. One example solution with these characteristics is shown in Figure \ref{bad-solution-unmodified-gwo}, where we have set the origin of the buildings to the center of the bounding region.

\begin{figure}[h!]
	\centering
	\includegraphics{./images/chap05-methodology/bad-solution-unmodified-gwo.png}
	\caption{Flowchart detailing the algorithm.}
	\label{bad-solution-unmodified-gwo}
\end{figure}

As one may infer, using the equations above will require setting an origin point for the buildings. Not considering the affinity of building towards the axes, having the origin point at the center or in a certain location in the bounding region restricts the possible locations where the buildings can cluster around. This restriction prevents us from exploring the solution subspace where solutions are feasible but where the cluster point is not the origin. This lead us to solutions that are less ideal. Aside from requiring setting the origin point, buildings moving towards the axes also presents another problem. Basing from our experiments, it prevents us from producing feasible solutions.

This behaviour can be attributed to the formulas, $\vec{D} = \left | \vec{C} \cdot \vec{X_{p}}(t) - \vec{X}(t) \right |$ and $\vec{A} \cdot \vec{D}$. Remember that the latter is from $\vec{X_{l}^{'}} = \vec{X_{l}}(t) - \vec{A_{l}} \cdot \vec{D_{l}}$, where $l$ represents the alpha, beta, or delta solution. To understand why the aforementioned formulas contribute to the behaviour we have discussed earlier, we should understand what any of the aforementioned formulas mean. It is helpful to simply consider that only building is being optimized in understanding the problems. Considering only the alpha solution may also provide better understanding as well.

Let us start with $\vec{C} \cdot \vec{X_{l}}(t)$ from $\vec{D} = \left | \vec{C} \cdot \vec{X_{l}}(t) - \vec{X}(t) \right |$. To simplify our explanation, let $K = \vec{C} \cdot \vec{X_{l}}(t)$. The range of each $i$th element in $K$ will be $[0, 2 \cdot \vec{C}_{l,i}]$. Note that the operation is dot product, but pairwise multiplication. This means that $K$ simply scales the x and y positions, and angle of the buildings. Figure \ref{gwo-c-effect} shows a visualization of this effect. Despite the figure only showing the effect with a building's position in the first quadrant, the same effect can be observed with other buildings located in other quadrants. Now, considering the entirety of $\vec{D}$, $\vec{D}$ would mean to be the distance between a building $i$ moved to a different point in the region $S$ (see Figure \ref{gwo-c-effect}) in $\vec{X_{l}}$ and a building $i$ in $\vec{X}(t)$. A visualization for this is provided by Figure \ref{gwo-d-effect}.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.45]{./images/chap05-methodology/gwo-c-effect.png}
	\caption{In $K$, $C$ simply scales the x and y positions and angles of buildings. Assuming that the point $B$ represents the x and y positions of a building, the region $S$ is where $B$ may be repositioned based on the values of $C$.}
	\label{gwo-c-effect}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.45]{./images/chap05-methodology/gwo-d-effect.png}
	\caption{A visualization of how $D$ is computed and its inherent meaning.}
	\label{gwo-d-effect}
\end{figure}

Since we now understand the meaning of $\vec{D}$, let us now move on to the other formula that causes the aforementioned problematic behaviour of classical GWO, $\vec{A} \cdot \vec{D}$. First, we should take note that $\vec{A} = 2 \cdot \vec{a} \cdot \vec{r_{1}} - \vec{a}$. $a$, as mentioned before, linearly decreases over time. Since $a$ decreases linearly over time, $\vec{A}$ will also decrease over time. This behaviour of $\vec{A}$ would mean that in $\vec{A} \cdot \vec{D}$, $\vec{D}$ will eventually decrease as well. This behaviour in itself is not a problem. This is a necessity as the buildings will not cluster together (and eventually produce a solution with a lower fitness value) if not for this behaviour. The major issue lies with how this behaviour interacts with $\vec{D}$. Over time through the course of iterations, $\vec{A}$ will eventually scale down the $\vec{D}$. This scaling down will also eventually reduce the size of each of the region $S$ of all buildings. This reduction of size will eventually cause the buildings to move towards the origin or the axes. Note that the penalty value for intersection prevents them from overlapping with one another. Buildings that are already on a certain axis will find it practically impossible to move in the direction of the perpendicular axis. Buildings that are on the origin itself will practically cease to move at all. Buildings will still be able to change their orientations, however. The reason for this behaviour of being stuck on an axis is due to the nature of axes themselves, where the value in one or both axes is zero. Since $K = \vec{C} \cdot \vec{X_{l}}(t)$ and when a building is near or already on an axis, the x, y, or both x and y positions of a building will barely, if at all, move away from the axes it is currently stuck to, when multiplying with $\vec{C}$. Hence, the behaviour we are noticing.

The two aforementioned formulas make classical GWO inadequate for our problem instance. We are unable to produce feasible nor satisfying results. In order for the grey wolf optimization algorithm to be successfully adapted into solving the facility layout problems, we must introduce a few changes into the algorithm. These changes will be discussed in the next subsection.

\subsection{Modified GWO}
% Draft Note: We should maybe give a name to the modified GWO. Maybe call it "Ballais-Romero GWO variant". HAHAHA.

Mirjalili, S., Mirjalili, S., and Lewis, A. \cite{Mirjalili2014} included a figure similar to Figure \ref{gwo-positioning-update}. It visualizes how a wolf $\omega$ will update its position based on the information provided by the leading wolves.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.3]{./images/chap05-methodology/gwo-position-updating.png}
	\caption{Visualization of how wolves in GWO update their positions. An $\omega$ wolf will move towards a random point inside the circle of the estimated prey position.}
	\label{gwo-positioning-update}
\end{figure}

Basing from the visualization, notice that the $\vec{C}$ of the leading wolves specify the radius of the circle in which a $\vec{C} \cdot \vec{X_{l}}$ will be located it. The circle does \textbf{not} include an origin point. We have discussed before that performing a pairwise multiplication between $\vec{C}$ and $\vec{X_{l}}$ simply scales the elements $i$ in the vector $\vec{X_{l}}$. This is different from the visualization. To achieve the same effect as the visualization, instead of performing pairwise multiplication, we must utilize vector addition between $\vec{C}$ and $\vec{X_{l}}$. See Figure \ref{vector-addition-visualization} for a visualization of vector addition. This is the first modification we are introducing to classical GWO.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.45]{./images/chap05-methodology/vector-addition-visualization.png}
	\caption{Vector addition pushes the point represented by $\vec{A}$ towards the direction of $\vec{B}$ by the magnitude of the same vector.}
	\label{vector-addition-visualization}
\end{figure}

In our modified GWO, $D$ is now defined as:

\begin{align}
	D &= \left | (\vec{C} + \vec{X_{l}}) - \vec{X}(t) \right | \label{modified-gwo-d}
\end{align}

However, this alone is not enough to comply with the aforementioned visualization. Using this will only move the buildings to the right and/or top. In order for us to move the buildings, we must also modify $\vec{C}$ as shown below:

\begin{align}
	C &= c \cdot \vec{r_{3}} \label{modified-gwo-c}
\end{align}

In this equation, $c$ is a real-valued variable, and $r_{3}$ is a random vector in $[-1, 1]$. This modification will now allow us to move a building from any direction and at any magnitude. The magnitude in which the building will be moved is controlled by $c$.

These modifications remove the necessity to specify an origin point in the bounding region, and the behaviour of buildings to move towards the origin or axes. Unfortunately, this alone is not enough to produce feasible results. We have to add two more modifications before we are able to produce good results.

The first additional modification is the building clamping. Each building is restricted to the boundary. If a building is moved towards outside the boundary, it will be pulled back to within the boundary. Building clamping can be mathematically defined as the following. Given a building $B$ in a solution $X(t)$ at iteration $t$ after being updated by Equations \ref{gwo-x1-eqn} to \ref{gwo-xt1-eqn}, \ref{modified-gwo-d}, and \ref{modified-gwo-c}, clamping can be mathematically modeled as:

\begin{align}
	B_{x} &= \text{max}\left (R_{x} + \frac{B_{w}}{2}, \text{min}\left(B_{x}, R_{x} + \left(R_{w} - \frac{B_{w}}{2}\right)\right)\right ) \\
	B_{y} &= \text{max}\left (R_{y} + \frac{B_{h}}{2}, \text{min}\left(B_{y}, R_{y} + \left(R_{h} - \frac{B_{h}}{2}\right)\right)\right )
\end{align}

where $B_{x}$ and $B_{y}$ are the $x$ and $y$ positions of the centroid of a building $B$, $B_{w}$ and $B_{h}$ are the width and height from the top left corner of a building $B$, $R_{x}$ and $R_{y}$ are the $x$ and $y$ positions of the top-left corner of the bounding region $R$, and $R_{w}$ and $R_{h}$ are the width and height of the bounding region $R$. Based on our prior experiments, without this clamping, buildings will freely move to points outside the boundary, and, at the end of the run, will produce a bad solution. 

This clamping should \textit{almost} solve the positioning of the buildings and allow us to produce results that are feasible. Since GWO is a continuous metaheuristic, building attributes that must only be one of two values will eventually be a value that is between the two aforementioned values. In our problem, this attribute that is affected is the building orientation. The building orientation may only be $0^{\circ}$ or $90^{\circ}$. It must never be a value between two. To solve this problem, we simply use the orientation of a building $B$ from the $\alpha$, $\beta$, or $\delta$ solutions, which are randomly selected. This idea is based off from the nature of GWO, where the best three solutions lead the search for the local optima. The building orientation of a building $B$ is, therefore, obtained using:

\begin{align}
	B_{o} = \left\{\begin{matrix}
		\alpha_{B_{o}} & \text{if } 0 \leq r < \frac{1}{3} \\ 
		\beta_{B_{o}}  & \text{if } \frac{1}{3} \leq r < \frac{2}{3}  \\ 
		\delta_{B_{o}} & \text{otherwise}
	\end{matrix}\right.
\end{align}

where $B_{o}$ is the current orientation of a building $B$, $\alpha_{B_{o}}$, $\beta_{B_{o}}$, and $\delta_{B_{o}}$ are the orientations of building $B$ in the $\alpha$, $\beta$, and $\delta$ solutions, respectively, and $r$ is a random variable in $[0, 1]$. In our approach, assigning the building orientations is performed before clamping the buildings.

All these modifications for the classical GWO have allowed us to successfully adapt GWO to the facility layout problem. Notice that these modifications are relatively simple, and do not significantly change the characteristics of classical GWO. The simplicity of GWO is still preserved. The next chapters will discuss how our modified version of GWO performs against configurations of unequal-area facility layout ptoblems.

(\textbf{COMMENT}: Sir, can we give this modified GWO a name? mGWO is already taken so maybe The Ballais-Romero GWO Variant? Still haven't came up with an alternative name. HAHAHAHAHAHAHA. \textbf{REMOVE THIS IN THE FINAL DRAFT, SEAN.})

%\section{The Algorithm}
%The proposed algorithm contains multiple phases to solve the unequal area static facility layout problem. The basic framework of the algorithm is inspired from the works of Asl et al. (2015) \cite{Asl2015} and Asl, A. and Wong, K. (2015) \cite{Asl2015}. The Grey Wolf Optimization aspect of the algorithm is inspired from Jiang, T. and Zhang, C. (2018) \cite{Jiang2018}. Figure \ref{algo-flowchart} shows a flowchart of the algorithm. We will be further discussing the algorithm in detail in this section.
%
%\begin{figure}[h!]
%	\centering
%	\includegraphics{./images/chap05-methodology/flowchart.png}
%	\caption{Flowchart detailing the algorithm.}
%	\label{algo-flowchart}
%\end{figure}
%
%\subsection{Population Generation}
%In generating the initial population, the order in which facilities are placed in the bounding region is shuffled. Once it is shuffled, each building $i$ is then given a random x position between the inclusive range $\left [ R_{x} + \frac{w_{i}}{2}, (R_{x} + R_{w}) - \frac{w_{i}}{2} \right ]$, a random y position between the inclusive range $\left [ R_{y} + \frac{h_{i}}{2}, (R_{y} + R_{h})  - \frac{h_{i}}{2} \right ]$, and angle that is either $0^{\circ}$ or $90^{\circ}$ (chosen in a uniformly random fashion). This will generate a solution where the buildings are spread out throughout the bounding region. There will be building intersections (though this is dependent on the number of buildings and size of the bounding region), but no building will be out-of-bounds. This process is repeated until we generate a specified number of solutions. This number is determined by the population size.
%
%\subsection{Swapping Method}
%The swapping method is used to find a possible configuration for a solution that is better than the current configuration. This method is applied to all solutions in the population, but only in the first 100 iterations. Pseudocode for the swapping method is provided in Algorithm \ref{pseudocode-swapping}.
%
%\begin{algorithm}
%\caption{Pseudocode for the swapping method.}
%\label{pseudocode-swapping}
%\begin{algorithmic}[1]
%\State Let $S$ be the collection of generated solutions.
%\State Set $S_{curr}$ be the current solution.
%\State Add $S_{curr}$ to $S$.
%\State Set $N_{B}$ be the maximum number of buildings.
%\For{i = 0 until $N_{B} - 2$}
%	\For{j = i + 1 until $N_{B} - 1$}
%		\State Building $i$'s orientation in $S_{curr}$ is changed to the other orientation,\WRP and the resulting new solution is added to $S$
%		\State Building $j$'s orientation in $S_{curr}$ is changed to the other orientation,\WRP and the resulting new solution is added to $S$
%		\State Building $i$'s and $j$'s orientations in $S_{curr}$ are changed to the other\WRP orientation, and the resulting new solution is added to $S$
%		\State Building $i$'s and $j$'s positions are exchanged in $S_{curr}$, and the resulting new\WRP solutiA movement and a orientation changeon is added to $S$.
%		\State Building $i$'s and $j$'s positions are exchanged in and the orientation of\WRP building $i$ is changed in $S_{curr}$, and the resulting new solution\WRP is added to $S$.
%		\State Building $i$'s and $j$'s positions are exchanged in and the orientation of\WRP building $j$ is changed in $S_{curr}$, and the resulting new solution\WRP is added to $S$.
%		\State Building $i$'s and $j$'s positions are exchanged in and the orientations of\WRP buildings $i$ and $j$ are changed in $S_{curr}$, and the resulting new solution\WRP is added to $S$.
%	\EndFor
%\EndFor \\
%\Return the best solution in $S$.
%\end{algorithmic}
%\end{algorithm}
%
%\subsection{Crossover, Mutation, and Elitism}
%Experimentations with directly applying the formulas of Grey Wolf Optimization in solving our instance of the facility layout problem have not generated satisfying results. However, results generated by an algorithm inspired from the paper of Jiang, T., and Zhang, C. (2018) \cite{Jiang2018} showed promise. As such the GWO portion of our proposed approach has been taken from their work. Their work takes certain elements from genetic algorithms, particularly the crossover and mutation operators, but kept the general principle of Grey Wolf optimization intact. We will be discussing each operator in detail in this section. Elitism is also implemented in our proposed approach to ensure that the best solutions found so far do not get lost throughout iterations. It will also be discussed in this section.
%
%\subsubsection{Crossover}
%Grey wolf optimization algorithms breed with the other solutions with the top three solutions in the population. That is modelled by the mathematical definition of the optimization algorithm. However, directly the definition does not yield good results. Due to that, we are using a crossover operator from the work of Jiang, T., and Zhang, C. (2018) \cite{Jiang2018}.
%
%The crossover operator used here can be mathematical defined as:
%
%$$
%X(t + 1) =
%\begin{cases}
%	f(X(t), X_{alpha}(t)) & \text{if }
%	\text{rnd} \leq \frac{1}{3} \\ 
%	f(X(t), X_{beta}(t)) & \text{if }
%	\frac{1}{3} < \text{rnd} \leq \frac{2}{3} \\
%	f(X(t), X_{delta}(t)) & \text{if }
%	\text{rnd} \geq \frac{2}{3}
%\end{cases} 
%$$
%
%where $f$ is the crossover function, and $\text{rnd} \sim U(0, 1)$. This means that a solution will be crossed over by one of the best three solutions, selected randomly. In our approach, we have used the uniform crossover. Note that this crossover is applied to every solution in a population in accordance with the principle of GWO. In our approach, only one offspring is generated from the crossover.
%
%\subsubsection{Mutation}
%Over time, as more and more iterations are performed, the diversity of the population will eventually be lost. This is due to the fact that the wolves are only updated based on the best three solutions. This will also result in premature convergence \cite{Jiang2018}. To combat this, a mutation operator is performed to reintroduce diversity. The mutation operator used is an operator that we dub the "Buddy-Buddy Mutation".
%
%The \textbf{Buddy-Buddy Mutation} is a mutation operator that simply selects two pairs of buildings $D$ and $S$, and move one of them to the side of the other building. Building $D$ is referred to as the dynamic buddy, while building $S$ is referred to as the static buddy. Building $D$ will be the building that will be moved towards the other building, which is building $S$ in our case. When moving building $D$, a side $E$ of building $S$ will first be randomly chosen. Afterwards, an orientation for building $D$ will be randomly chosen, whether it will be parallel or perpendicular to $E$. Once a side and orientation has been selected, building $D$ will be moved adjacent towards building $S$ at side $E$ with the chosen orientation. The implementation of this mutation operator in our proposed approach gives buildings that intersect with another building more chances of being selected as the dynamic buddy. Pseudocode and a visualization of the operator is provided by Algorithm \ref{pseudocode-buddybuddy-mutation} and Figure \ref{buddy-buddy-mutation-viz}, respectively.
%
%\begin{algorithm}
%	\caption{Pseudocode for the Buddy-Buddy Mutation.}
%	\label{pseudocode-buddybuddy-mutation}
%	\begin{algorithmic}[1]
%		\State Randomly select two buildings $D$ and $S$, with more weight given to buildings that are intersecting with another.
%		\State Set $E$ to be a randomly selected side of building $S$.
%		\State Set $O$ to either be a parallel or perpendicular orientation, randomly selected.
%		\State Move building $D$ adjacent to side $E$ of building $S$ with the orientation $O$.
%	\end{algorithmic}
%\end{algorithm}
%
%The rate at which a solution is mutated is highly dependent on the fitness of the solution. The worse the fitness of a solution is, the more likely it is to be mutated. This encourages the proposed algorithm to improve solutions that are generally bad. This rate scheme makes this an adaptive mutation operator \cite{Jiang2018}. The mutation rate is mathematically modelled as:
%
%\begin{equation}
%	m(X, t) = 1 - \frac{fit_{max}(t) - fit(X(t))}{fit_{max}(t) - fit_{min}(t)}
%\end{equation}
%
%where $m_{k}$ refers to the mutation rate of a solution $X$ at iteration $t$, $fit$ is a function that gets the fitness of a solution, and $fit_{min}$ and $fit_{max}$ gets the minimum and maximum fitnesses of the population, respectively.
%
%\subsubsection{Elitism}
%One variant of genetic algorithms includes elitism. This elitism allows a genetic algorithm to keep a number of best solutions in the next generation, ensuring that the best solutions do not get discarded over time. Note that this elitism strategy is not only limited to genetic algorithms. Other evolutionary algorithms may also utilize this strategy \cite{Du2018}. We are also taking this principle into our proposed approach. In our proposed approach, we are keeping the best three solutions in the previous iteration to the next iteration. We chose three due to the fact that the best three solutions in a population have significance in GWO.
%
%\subsection{Local Searches}
%Remember that our implementation is based on aforementioned previous works that used local search algorithms in conjunction to genetic algorithms. They combined GAs with local search algorithms because GAs find it hard to explore within the convergence area. Hybridizing it with a local search algorithm improves performance \cite{Ripon2013}. In our proposed approach, we are keeping this aspect of the previous works. This will also ensure that we are able to search within the convergence area more intensely and find better solutions. In the previous works and in ours, there are two local search algorithms, dubbed "Local Search 1" and "Local Search 2". They vary in terms of searching intensity, but both attempts to obtain better solutions. We will be discussing details of both in this section.
%
%\subsubsection{Local Search 1}
%The first local search algorithm, "Local Search 1", performs a local search by creating a number of solutions by moving each building in different directions by a certain random amount and changing its orientations after movement and obtaining the best solution from these activities. In our approach, the certain amount of movement is a random number between 1 and 5. This search algorithm is only applied to the best solution of the current iteration, and the best solution found in this search becomes the new best solution and replaces the previously best solution. The movements of each building is defined by a set of "activities". This set of activities is shown by Table \ref{local-search-1-activities}. Additionally, pseudocode of the search algorithm is shown in Algorithm \ref{pseudocode-local-search-1}.
%
%\begin{table}[h!]
%	\centering
%	\begin{tabular}{| c | p{110mm} |}
%		\hline
%		Activity Number & Description \\
%		\hline
%		0 & A building is moved to the right along the x-axis by a random number between 1 and 5. \\
%		1 & A building is moved to the left along the x-axis by a random number between 1 and 5. \\
%		2 & A building is moved to the upwards along the y-axis by a random number between 1 and 5. \\
%		3 & A building is moved to the downwards along the y-axis by a random number between 1 and 5. \\
%		4 & Generate two random numbers from 1 and 5 and a building is moved to the right and then upward, respectively, by those numbers. \\
%		5 & Generate two random numbers from 1 and 5 and a building is moved to the right and then downward, respectively, by those numbers. \\
%		6 & Generate two random numbers from 1 and 5 and a building is moved to the left and then upward, respectively, by those numbers. \\
%		7 & Generate two random numbers from 1 and 5 and a building is moved to the left and then downward, respectively, by those numbers. \\
%		\hline
%	\end{tabular}
%	\caption{Activities for moving a building in Local Search 1}
%	\label{local-search-1-activities}
%\end{table}
%
%\begin{algorithm}[h!]
%\caption{Pseudocode for Local Search 1.}
%\label{pseudocode-local-search-1}
%\begin{algorithmic}[1]
%\State Set $S$ to be a collection of solutions.
%\State Set $S_{curr}$ to be the solution being optimized.
%\State Add $S_{curr}$ to $S$.
%\State Set $N_{B}$ be the maximum number of buildings.
%\State Set $N_{A}$ be the maximum number of activities.
%\For{i = 0 until $N_{B} - 1$}
%	\For{a = 0 until $N_{B} - 1$}
%		\State Perform activity $a$ with building $i$ in $S_{curr}$ and save the new solution in $S$.
%		\State Perform activity $a$ with building $i$, and change the orientation of the building to the other orientation in $S_{curr}$ and save the new solution in $S$.
%	\EndFor
%\EndFor \\
%\Return the best solution in $S$.
%\end{algorithmic}
%\end{algorithm}
%
%\subsubsection{Local Search 2}
%Local Search 2 is a more intense version of Local Search 1, in order to find the best solution so far. Unlike the latter that only moves one building at a time, Local Search 2 moves two buildings instead. The two buildings will also have their orientations changed after each activity. This local search is only applied to the best solution found in the last 50 iterations. The set of activities for this local search is shown by Table \ref{local-search-2-activities}, and a pseudocode of the search algorithm is shown in Algorithm \ref{pseudocode-local-search-2}.
%
%\begin{algorithm}[h!]
%	\caption{Pseudocode for Local Search 2.}
%	\label{pseudocode-local-search-2}
%	\begin{algorithmic}[1]
%		\State Set $S$ to be a collection of solutions.
%		\State Set $S_{curr}$ to be the solution being optimized.
%		\State Add $S_{curr}$ to $S$.
%		\State Set $N_{B}$ be the maximum number of buildings.
%		\State Set $N_{A}$ be the maximum number of activities.
%		\For{i = 0 until $N_{B} - 2$}
%		\For{a = 0 until $N_{B} - 1$}
%		\State Perform activity $a$ with building $i$ in $S_{curr}$ and save the new solution in $S$.
%		\State Perform activity $a$ with building $i$, and change the orientation of \WRP building $i$ to the other orientation in $S_{curr}$ and save the new \WRP solution in $S$.
%		\State Perform activity $a$ with building $i$, and change the orientation of \WRP building $i + 1$ to the other orientation in $S_{curr}$ and save the new \WRP solution in $S$.
%		\State Perform activity $a$ with building $i$, and change the orientations of \WRP buildings $i$ and $i + 1$ to the other orientations in $S_{curr}$ and save the new \WRP solution in $S$.
%		\EndFor
%		\EndFor \\
%		\Return the best solution in $S$.
%	\end{algorithmic}
%\end{algorithm}
%
%\begin{longtable}{| c | p{120mm} |}
%	\hline
%	Activity Number & Description \\
%	\hline
%	0  & Building $i$ and $i + 1$ are moved to the right along the x-axis by a random number between 1 and 5. \\
%	1  & Building $i$ and $i + 1$ are moved to the left along the x-axis by a random number between 1 and 5. \\
%	2  & Building $i$ and $i + 1$ are moved upwards along the x-axis by a random number between 1 and 5. \\
%	3  & Building $i$ and $i + 1$ are moved downwards along the x-axis by a random number between 1 and 5. \\
%	4  & Generate two random numbers from 1 and 5 and buildings $i$ and $i + 1$ are moved to the right and then upward, respectively, by those numbers. \\
%	5  & Generate two random numbers from 1 and 5 and buildings $i$ and $i + 1$ are moved to the right and then downward, respectively, by those numbers. \\
%	6  & Generate two random numbers from 1 and 5 and buildings $i$ and $i + 1$ are moved to the left and then upward, respectively, by those numbers. \\
%	7  & Generate two random numbers from 1 and 5 and buildings $i$ and $i + 1$ are moved to the left and then downward, respectively, by those numbers. \\
%	8  & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved upward by $a$ and building $i + 1$ is moved to the right by $b$. \\
%	9  & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved upward by $a$ and building $i + 1$ is moved downward by $b$. \\
%	10 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved upward by $a$ and building $i + 1$ is moved to the left by $b$. \\
%	11 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved to the right by $a$ and building $i + 1$ is moved downward by $b$. \\
%	12 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved to the right by $a$ and building $i + 1$ is moved upward by $b$. \\
%	13 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved to the right by $a$ and building $i + 1$ is moved to the left by $b$. \\
%	14 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved to the left by $a$ and building $i + 1$ is moved to downward by $b$. \\
%	15 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved to the left by $a$ and building $i + 1$ is moved to the right by $b$. \\
%	16 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved to the left by $a$ and building $i + 1$ is moved upward by $b$. \\
%	17 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved downward by $a$ and building $i + 1$ is moved to the right by $b$. \\
%	18 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved downward by $a$ and building $i + 1$ is moved to the left by $b$. \\
%	19 & Generate two random numbers $a$ and $b$ that are from 1 to 5, and building $i$ is moved downward by $a$ and building $i + 1$ is moved upward by $b$. \\
%	\hline
%	\caption{Activities for moving a building in Local Search 2}
%	\label{local-search-2-activities}
%\end{longtable}

\section{Implementation Technologies}
Our proposed approach was developed using C++17 compiled using the Clang 11 compiler in an elementaryOS Hera environment. Building was handled by CMake, and package management was handled by Conan. Our implementation is built on top of CoreX, a custom-developed 2D game engine. Using a game engine allowed us to visualize the results and configure experiments in a graphical manner. Using a custom engine over an over-the-shelf engine ensures that the implementation remains light and does not carry unnecessary features that are typically used in commercial game engines. The libraries EASTL, ImGUI, SDL 2, SDL 2 TTF. sdl-gpu, nlohmann JSON, and EnTT were used in developing the engine, with EnTT and ImGUI directly used by our implementation itself.